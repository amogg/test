/*
 * HIWARE Driver (Nanwflt/Nadprvd) IOCTL Logger
 * 1. Hooks CreateFileW to identify HIWARE handles.
 * 2. Hooks DeviceIoControl to log traffic ONLY for those handles.
 */

// HIWARE 관련 드라이버/디바이스 이름 키워드
// 파일명 기반으로 추측: nanwflt, nadprvd
const TARGET_KEYWORDS = ["nanwflt", "nadprvd", "netand"];

// HIWARE라고 확인된 핸들을 저장하는 저장소 (Set)
const hiwareHandles = new Set();

const C_CREATE = "\x1b[33m"; // Yellow (CreateFile)
const C_SEND   = "\x1b[36m"; // Cyan (Input)
const C_RECV   = "\x1b[32m"; // Green (Output)
const C_RESET  = "\x1b[0m";

function hookKernel32() {
    const kernel32 = "kernel32.dll";
    const createFileW = Module.findExportByName(kernel32, "CreateFileW");
    const deviceIoControl = Module.findExportByName(kernel32, "DeviceIoControl");
    const closeHandle = Module.findExportByName(kernel32, "CloseHandle");

    if (!createFileW || !deviceIoControl) {
        console.error("[-] Failed to find Kernel32 exports.");
        return;
    }

    console.log("[+] Monitoring CreateFileW & DeviceIoControl for keywords: " + TARGET_KEYWORDS.join(", "));

    // 1. CreateFileW 후킹: 드라이버를 열 때 핸들을 납치
    Interceptor.attach(createFileW, {
        onEnter(args) {
            // LPCWSTR lpFileName
            this.fileName = ptr(args[0]).readUtf16String();
        },
        onLeave(retval) {
            if (this.fileName) {
                const lowerName = this.fileName.toLowerCase();
                
                // 키워드가 포함된 디바이스인지 확인
                for (const keyword of TARGET_KEYWORDS) {
                    if (lowerName.includes(keyword)) {
                        const handle = retval.toString();
                        hiwareHandles.add(handle); // 핸들 등록
                        
                        console.log(`${C_CREATE}[+] HIWARE Driver Opened!${C_RESET}`);
                        console.log(`    Name  : ${this.fileName}`);
                        console.log(`    Handle: ${handle}`);
                        console.log("---------------------------------------------------");
                        break;
                    }
                }
            }
        }
    });

    // 2. CloseHandle 후킹: 핸들을 닫으면 목록에서 제거 (메모리 관리)
    Interceptor.attach(closeHandle, {
        onEnter(args) {
            const handle = ptr(args[0]).toString();
            if (hiwareHandles.has(handle)) {
                hiwareHandles.delete(handle);
                // console.log(`[-] HIWARE Handle closed: ${handle}`);
            }
        }
    });

    // 3. DeviceIoControl 후킹: 등록된 핸들인 경우에만 로그 출력
    Interceptor.attach(deviceIoControl, {
        onEnter(args) {
            // BOOL DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped)
            const handle = ptr(args[0]).toString();
            
            // ★ 핵심: HIWARE 핸들인지 체크
            if (hiwareHandles.has(handle)) {
                this.isTarget = true;
                this.ioCode = ptr(args[1]);
                this.inBuf = ptr(args[2]);
                this.inLen = ptr(args[3]).toInt32();
                this.outBuf = ptr(args[4]);
                this.outMaxLen = ptr(args[5]).toInt32();
                this.bytesRetPtr = ptr(args[6]);

                console.log(`${C_SEND}[SEND] DeviceIoControl (Handle: ${handle})${C_RESET}`);
                console.log(`    Code: ${this.ioCode} (0x${this.ioCode.toString(16)})`);
                
                if (this.inLen > 0) {
                    console.log(`    InSize: ${this.inLen} bytes`);
                    try {
                        console.log(hexdump(this.inBuf, { length: this.inLen, header: false, ansi: true }));
                    } catch (e) { console.log("    (Error reading input buffer)"); }
                } else {
                    console.log("    InSize: 0 bytes");
                }
            }
        },
        onLeave(retval) {
            if (this.isTarget) {
                // 리턴값이 0이 아니면 성공
                if (retval.toInt32() !== 0) {
                    // 실제로 받은 바이트 수 확인
                    let actualLen = 0;
                    if (!this.bytesRetPtr.isNull()) {
                        actualLen = this.bytesRetPtr.readU32();
                    } else {
                        // 비동기(Overlapped)가 아니면 보통 여기서 알기 어려울 수 있으나, 
                        // 동기 호출일 경우 lpBytesReturned가 채워짐.
                        // 만약 0이라면 outMaxLen을 참고하되, 정확하지 않을 수 있음.
                        actualLen = 0; 
                    }

                    if (actualLen > 0) {
                        console.log(`${C_RECV}[RECV] Response from Driver${C_RESET}`);
                        console.log(`    OutSize: ${actualLen} bytes`);
                        try {
                            console.log(hexdump(this.outBuf, { length: actualLen, header: false, ansi: true }));
                        } catch (e) { console.log("    (Error reading output buffer)"); }
                    }
                } else {
                    // 실패 시 에러 코드 (필요하면 GetLastError 호출 로직 추가 가능)
                    // console.log("    [!] DeviceIoControl Failed");
                }
                console.log("---------------------------------------------------\n");
            }
        }
    });
}

// 스크립트 로드
setTimeout(hookKernel32, 100);
