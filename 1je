/*
 * Windows OpenSSL (libssl/ssleay32) Traffic Logger for Frida - Fixed
 */

function findSslModule() {
    var modules = Process.enumerateModules();
    var targetModule = null;
    var patterns = ["libssl", "ssleay32", "libcrypto"];

    for (var i = 0; i < modules.length; i++) {
        var name = modules[i].name.toLowerCase();
        for (var j = 0; j < patterns.length; j++) {
            if (name.indexOf(patterns[j]) !== -1) {
                if (name.indexOf("crypto") === -1 || patterns[j] === "libcrypto") {
                    targetModule = modules[i].name;
                    break;
                }
            }
        }
        if (targetModule) break;
    }
    return targetModule;
}

function hookSSL() {
    var moduleName = findSslModule();

    if (!moduleName) {
        console.error("[-] SSL Library not found.");
        return;
    }

    console.log("[+] Found SSL Module: " + moduleName);

    var sslWriteAddr = Module.findExportByName(moduleName, "SSL_write");
    var sslReadAddr = Module.findExportByName(moduleName, "SSL_read");

    if (!sslWriteAddr || !sslReadAddr) {
        console.error("[-] Could not find exports.");
        return;
    }

    var COLOR_SEND = "\x1b[36m"; 
    var COLOR_RECV = "\x1b[32m"; 
    var COLOR_RESET = "\x1b[0m";

    // SSL_write 후킹
    Interceptor.attach(sslWriteAddr, {
        onEnter: function(args) {
            var ssl = args[0];
            var buf = args[1];
            
            // [수정] .toInt32() 대신 parseInt() 사용 (호환성 확보)
            // args[2]가 NativePointer 객체든 숫자든 안전하게 정수로 변환합니다.
            var num = parseInt(args[2]);

            if (num > 0) {
                console.log(COLOR_SEND + "[+] SSL_write (Size: " + num + ")" + COLOR_RESET);
                try {
                    console.log(hexdump(buf, {
                        offset: 0,
                        length: num,
                        header: false,
                        ansi: true
                    }));
                } catch (e) {
                    console.log("[!] Error dumping hex: " + e.message);
                }
                console.log("\n");
            }
        }
    });

    // SSL_read 후킹
    Interceptor.attach(sslReadAddr, {
        onEnter: function(args) {
            this.ssl = args[0];
            this.buf = args[1];
            // [수정] 여기도 동일하게 수정
            this.num = parseInt(args[2]);
        },
        onLeave: function(retval) {
            // [수정] 리턴값도 parseInt()로 처리
            var numRead = parseInt(retval);

            if (numRead > 0) {
                console.log(COLOR_RECV + "[+] SSL_read (Size: " + numRead + ")" + COLOR_RESET);
                try {
                    console.log(hexdump(this.buf, {
                        offset: 0,
                        length: numRead,
                        header: false,
                        ansi: true
                    }));
                } catch (e) {
                     console.log("[!] Error dumping hex: " + e.message);
                }
                console.log("\n");
            }
        }
    });
}

setTimeout(hookSSL, 1000);
